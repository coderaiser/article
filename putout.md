# Использование AST-деревьев JavaScript, на примере putout
# Практическое применение AST-деревьев

## Содержание

- Введение
- Что такое AST?
- Как строится AST?
- Примеры парсеров
- Кто использует AST?
    - `babel`
    - `eslint`
    - `jscodeshift`
    - `prettier`
    - `putout`
- Трансформация AST на примере плагинов `putout`


# Как строится AST

## ПАРСЕР

Рассмотрим работу парсера на примере кода:

```js
a + b
```

Обычно парсеры делятся на две части:

1. Лексический анализ

Разбивает код на токены, каждый из которых описывает часть кода:

```json
[{
    "type": "Identifier",
    "value": "a"
}, {
    "type": "Punctuator",
    "value": "+",
}, {
    "type": "Identifier",
    "value": "b"
}]
```

2. Синтаксический анализ.

Строит из токенов синтаксическое дерево:

```json
{
    "type": "BinaryExpression",
    "left": {
        "type": "Identifier",
        "name": "a"
    },
    "operator": "+",
    "right": {
        "type": "Identifier",
        "name": "b"
    }
}
```

## Putout

Putout - это трансформатор кода с поддержкой плагинов. По сути это нечто среднее между `eslint` и `babel`.
Объединяющий в себе достоинства обоих инструментов.

Как и `eslint` `putout` показывает проблемные места в коде, но в отличие от `eslint` `putout` меняет поведение кода, то есть может исправлять ошибки которые находят.

Как и `babel` `putout` преобразовывает код, но старается его минимально менять, таким образом его можно применять для работы с кодом, который хранится в репозитории.
