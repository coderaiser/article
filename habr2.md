# Cloud Commander 2.0
[habr]: habrahabr.ru/post/226257/ "Двухпанельный веб-файл менеджер Cloud Commander"

## Вступление
В [прошлой статье][habr] было рассказано о том, что из себя представляет Cloud Commander,
об основных причинах появления, недостатках, достоинствах, процессе разработки, а так же философии
файлового менеджера. Сегодня мы поговорим о том, что изменилось и как это влияет на дальнешее
развитие приложения. В статье будет рассмотрено множество модулей node.js, о которых читатели возможно
не слышали.

## Изминения
Главным изминением можно считать смену курса развития. Раньше `Cloud Commander` развивался как цельное
монолитное приложение, которое не зависило от сторонних модулей, могло их использовать, если они были
в наличии, но могло и обходится без них лишаясь части функциональности, но при этом стабильно работая.

Минусов в таком подходе несколько:
- После того, как часть приложения была улучшена новым функционалом или исправленными багами,
она не могла стать доступной до тех пор, пока не обновится все приложение, в котором тем временем
появлялась новая порция багов, и так без конца. Поскольку компоненты друг от друга зависят мало,
пользователь, ожидая, что в новом релизе починят меню в редакторе мог наткнутся на то, меню работает
отлично, но теперь поломалась консоль. И починят ее только в новой версии, через несколько месяцев,
поломав что-то другое.

- Монолитное приложение сложно документировать не только потому, что оно само на себе завязано, и в нем
постоянно что-то меняется, а еще и по той причине, что оно достаточно большое, и документирование
такого гиганта означает заморозку в развитии, либо поддержку не актуальной документации. В любом случае
документирование всего подряд может себя не окупить, и иногда лучше просто рефакторить код, что бы он был
понятен сам по себе.

- В монолитном коде высок порог вхождения, есть большая разница в том, смотреть на функцию в 10 строк или
10 страниц, и дело тут не только в опытности разработчка, в котором возникло желание внести изминения в
программу, а еще и в том, что психологически гораздо проще понять, вникнуть и осознать короткий код. Проще
найти ошибку: логическу или опечатку. И гораздо проще вносить изминения, не только основным разработчикам,
но и новичкам.

В предыдущей статье говорилось о том, что `Cloud Commander` использует модули. И это правда, с первых дней
разработки, приложение писалось таким образом, что бы код мог использоватся повторно. Таким образом функционал,
который повторно используется выносился в отдельные функции и файлы. Но он весь реализовывался в рамках
одного проекта, с использованием особенностей присущих лишь этому проекту. Соответственно код не был
переносим в полной мере, его не могли просто взять и использовать в других приложениях. Он был завязан
сам на себе.

Осознавая это, очень сложно было бы продолжать разработку в той же манере. Было принято решение о том,
что функционал, который может быть использован повторно должен быть вынесен в отдельные модули `npm`.
Где они смогут повторно использоватся другими людьми, которые возможно захотят улучшить код, или найдут
в нем ошибку. В конечном итоге от этого выиграют все.

## Состав

Итак, версия `2.0` подразумевает не потерю обратной совместимости, а сдвиг в философии проекта. Та часть,
которая могла быть вынесена обрела новый репозиторий, место в `npm` и возможность использоватся в других
приложениях. Таких модулей оказалось довольно много, и о них мы поговорим.

### Minify

[minify](http://coderaiser.github.io/minify "Minify") представляет из себя солянку из модулей, которые обрабатывают: js, css, html и переводят изображения в
base64, при этом результат складывают в папку tmp, для более быстрого получения результата, при следующем
обращении.

### Join

Есть разные способы ускороить загрузку веб-страницы: обьединить файлы, минифицировать, скомпилировать с помощью
`brawserify`. [join](https://github.com/coderaiser/join-io "Join") работает иначе, но цель у него та же самая.
Он склеивает файлы на лету в один http-запрос, при этом, при необходимости, минифицируя их, с помощью `Minify`.
Подключить его достаточно просто, поскольку он представляет из себя `middleware` совместимый с
[express](http://expressjs.com "Express"). И такого кода вполне достаточно:

```js
app.use(join({
    dir: __dirname
}));
```

Склеивание, в свою очередь, происходит таким образом:

```html
<link rel="/join:/css/normilize.css:/css/style.css">
```

## Разработка
## Послесловие
