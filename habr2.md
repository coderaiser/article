# Cloud Commander 2.0
[habr]: habrahabr.ru/post/226257/ "Двухпанельный веб-файл менеджер Cloud Commander"

## Вступление
В [прошлой статье][habr] было рассказано о том, что из себя представляет Cloud Commander,
об основных причинах появления, недостатках, достоинствах, процессе разработки, а так же философии
файлового менеджера. Сегодня мы поговорим о том, что изменилось и как это влияет на дальнешее
развитие приложения. В статье будет рассмотрено множество модулей node.js, о которых читатели возможно
не слышали.

## Изминения
Главным изминением можно считать смену курса развития. Раньше `Cloud Commander` развивался как цельное
монолитное приложение, которое не зависило от сторонних модулей, могло их использовать, если они были
в наличии, но могло и обходится без них лишаясь части функциональности, но при этом стабильно работая.

Минусов в таком подходе несколько:
- После того, как часть приложения была улучшена новым функционалом или исправленными багами,
она не могла стать доступной до тех пор, пока не обновится все приложение, в котором тем временем
появлялась новая порция багов, и так без конца. Поскольку компоненты друг от друга зависят мало,
пользователь, ожидая, что в новом релизе починят меню в редакторе мог наткнутся на то, что меню работает
отлично, но теперь поломалась консоль. И починят ее только в новой версии, через несколько месяцев,
поломав что-то другое.

- Монолитное приложение сложно документировать не только потому, что оно само на себе завязано, и в нем
постоянно что-то меняется, а еще и по той причине, что оно достаточно большое, и документирование
такого гиганта означает заморозку в развитии, либо поддержку не актуальной документации. В любом случае
документирование всего подряд может себя не окупить, и иногда лучше просто рефакторить код, что бы он был
понятен сам по себе.

- В монолитном коде высок порог вхождения, есть большая разница в том, смотреть на функцию в 10 строк или
10 страниц, и дело тут не только в опытности разработчка, в котором возникло желание внести изминения в
программу, а еще и в том, что психологически гораздо проще понять, вникнуть и осознать короткий код. Проще
найти ошибку: логическу или опечатку. И гораздо проще вносить изминения, не только основным разработчикам,
но и новичкам.

В [предыдущей статье][habr] говорилось о том, что `Cloud Commander` использует модули. И это правда, с первых дней
разработки, приложение писалось таким образом, что бы код мог использоватся повторно. Таким образом функционал,
который повторно используется выносился в отдельные функции и файлы. Но он весь реализовывался в рамках
одного проекта, с использованием особенностей присущих лишь этому проекту. Соответственно код не был
переносим в полной мере, его не могли просто взять и использовать в других приложениях. Он был завязан
сам на себе.

Осознавая это, очень сложно было бы продолжать разработку в той же манере. Было принято решение о том,
что функционал, который может быть использован повторно должен быть вынесен в отдельные модули `npm`.
Где они смогут повторно использоватся другими людьми, которые возможно захотят улучшить код, или найдут
в нем ошибку. В конечном итоге от этого выиграют все.

## Состав

Итак, версия `2.0` подразумевает не потерю обратной совместимости, а сдвиг в философии проекта. Та часть,
которая могла быть вынесена обрела новый репозиторий, место в `npm` и возможность использоватся в других
приложениях. Таких модулей оказалось довольно много, и о них мы поговорим.

### Minify

[minify](http://coderaiser.github.io/minify "Minify") представляет из себя солянку из модулей, которые обрабатывают: js, css, html и переводят изображения в
base64. При этом результат складывают в папку tmp, для более быстрого получения результата, при следующем
обращении. Делается это с помощью модуля [tomas](https://github.com/coderaiser/node-tomas "Tomas").

### Join

Есть разные способы ускороить загрузку веб-страницы: обьединить файлы, минифицировать, скомпилировать с помощью
`brawserify`. [join](https://github.com/coderaiser/join-io "Join") работает иначе, но цель у него та же самая.
Он склеивает файлы на лету в один http-запрос, при этом, при необходимости, минифицируя их, с помощью `Minify`.
Подключить его достаточно просто, поскольку он представляет из себя `middleware` совместимый с
[express](http://expressjs.com "Express"). И такого кода вполне достаточно:

```js
app.use(join({
    dir: __dirname
}));
```

Склеивание, в свою очередь, происходит таким образом:

```html
<link rel="/join:/css/normilize.css:/css/style.css">
```

### Console

[Console](https://github.com/cloudcmd/console-io "Console") - еще один `middleware` совместимый с `express`.
Подключается в пару строчек: на сервере и клиенте.

Вот часть на сервере:

```js
onsole({
    server: server,     /* only one should be passed: */
    socket: socket,     /* server or socket  */
    online: true,       /* default */
    minify: true,       /* default */
    prefix:'/console'   /* default */
})
```

И на клиенте:

```html
<div class="console"></div>
<script src="/console/console.js"></script>
<script>
Console('.console', function() {
    console.log('console ready')
});
</script>
```

В результате мы получаем консоль, которая может принимать команды на клиенте и выполнять их на сервере.

### Edward

Редактор, основанный на [ace](http://ace.c9.io "Ace") так же выделился в отдельный модуль,
который может использовать не только Cloud Commander, но и любое другое приложение, так как это тоже `express middleware`.
Из коробки есть горячие клавиши, а так же `minify` и `beautify`. Для начала использования достаточно кода на сервере:

```js
app.use(edward({
    minify  : true,  /* default */
    online  : false, /* default */
    diff    : true,  /* default */
    zip     : true   /* default */
}));
```

И клиенте :

```html
<div class="edit" data-name="js-edit"></div>
<script src="/edward/edward.js"></script>
```

```css
html, body, .edit {
    height: 100%;
    margin: 0;
}
```

```js
edward('[data-name="js-edit"]', function(el) {
    console.log('edward is ready');
});
```

### Mollify

Последним middleware на сегодня будет [mollify](https://github.com/coderaiser/mollify). Он позволяет на лету
минифицировать `js`, `css` и `html`. Для этого он использует *Minify* описанный выше.

### Rendy

Когда нужен действительно простой шаблонизатор [rendy](https://github.com/coderaiser/rendy "Rendy") может пригодится.
Он делает одну вещь. Делает это максимально просто. Работает во всех окружениях, поддерживающих ES5.
Использовать можно таким образом:

```js
    var Tmpl    = 'hello {{ where }}';
        result  = rendy(Tmpl, {
            where: 'in browser'
        });
        // returns
        'hello in browser'
```

## Разработка
## Послесловие
