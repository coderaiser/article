# Cloud Commander 2.0
[habr]: habrahabr.ru/post/226257/ "Двухпанельный веб-файл менеджер Cloud Commander"

## Вступление
В [прошлой статье][habr] было рассказано о том, что из себя представляет Cloud Commander,
об основных причинах появления, недостатках, достоинствах, процессе разработки, а так же философии
файлового менеджера. Сегодня мы поговорим о том, что изменилось и как это влияет на дальнешее
развитие приложения. В статье будет рассмотрено множество модулей node.js, о которых читатели возможно
не слышали.

## Изминения
Главным изминением можно считать смену курса развития. Раньше `Cloud Commander` развивался как цельное
монолитное приложение, которое не зависило от сторонних модулей, могло их использовать, если они были
в наличии, но могло и обходится без них лишаясь части функциональности, но при этом стабильно работая.

Минусов в таком подходе несколько:

- После того, как часть приложения была улучшена новым функционалом или исправленными багами,
она не могла стать доступной до тех пор, пока не обновится все приложение, в котором тем временем
появлялась новая порция багов, и так без конца. Поскольку компоненты друг от друга зависят мало,
пользователь, ожидая, что в новом релизе починят меню в редакторе мог наткнутся на то, что меню работает
отлично, но теперь поломалась консоль. И починят ее только в новой версии, через несколько месяцев,
поломав что-то другое.

- Монолитное приложение сложно документировать не только потому, что оно само на себе завязано, и в нем
постоянно что-то меняется, а еще и по той причине, что оно достаточно большое, и описание функционала
такого гиганта означает заморозку в развитии, либо поддержку не актуальной документации. В любом случае
документирование всего подряд может себя не окупить, и иногда лучше просто рефакторить код, что бы он был
понятен сам по себе.

- В монолитном коде высок порог вхождения, есть большая разница в том, смотреть на функцию в 10 строк или
10 страниц, и дело тут не только в опытности разработчика, в котором возникло желание внести изминения в
программу, а еще и в том, что психологически гораздо проще понять, вникнуть и осознать короткий код. Проще
найти ошибку: логическую или опечатку. И гораздо проще вносить изминения, не только основным разработчикам,
но и новичкам.

В [предыдущей статье][habr] говорилось о том, что `Cloud Commander` использует модули. И это правда, с первых дней
разработки, приложение писалось таким образом, что бы код мог использоватся повторно. Таким образом функционал,
который повторно используется выносился в отдельные функции и файлы. Но он весь реализовывался в рамках
одного проекта, с использованием особенностей присущих лишь этому проекту. Соответственно код не был
переносим в полной мере, его не могли просто взять и использовать в других приложениях. Он был завязан
сам на себе.

Осознавая это, очень сложно было бы продолжать разработку в той же манере. Было принято решение о том,
что функционал, который может быть использован повторно должен быть вынесен в отдельные модули `npm`.
Где они смогут повторно использоватся другими людьми, которые возможно захотят улучшить код, или найдут
в нем ошибку. В конечном итоге от этого выиграют все.

## Состав

Итак, версия `2.0` подразумевает не потерю обратной совместимости, а сдвиг в философии проекта. Та часть,
которая могла быть вынесена обрела новый репозиторий, место в `npm` и возможность использоватся в других
приложениях. Таких модулей оказалось довольно много, и о них мы поговорим.

### Minify

[minify](http://coderaiser.github.io/minify "Minify") представляет из себя солянку из модулей, которые обрабатывают: js, css, html и переводят изображения в
base64. При этом результат складывают в папку tmp, для более быстрого получения результата, при следующем
обращении. Делается это с помощью модуля [tomas](https://github.com/coderaiser/node-tomas "Tomas").

### Join

Есть разные способы ускорить загрузку веб-страницы: обьединить файлы, минифицировать, скомпилировать с помощью
`brawserify`. [join](https://github.com/coderaiser/join-io "Join") работает иначе, но цель у него та же самая.
Он склеивает файлы на лету в один http-запрос, при этом, при необходимости, минифицируя их, с помощью `Minify`.
Подключить его достаточно просто, поскольку он представляет из себя `middleware` совместимый с
[express](http://expressjs.com "Express"). И такого кода вполне достаточно:

```js
app.use(join({
    dir: __dirname
}));
```

Склеивание, в свою очередь, происходит таким образом:

```html
<link rel="/join:/css/normilize.css:/css/style.css">
```

### Console

![Console](https://raw.githubusercontent.com/cloudcmd/console/master/img/console.png "Console")

[Console](https://github.com/cloudcmd/console-io "Console") - еще один `middleware` совместимый с `express`.
Подключается в пару строчек: на сервере и клиенте.

Вот часть на сервере:

```js
onsole({
    server: server,     /* only one should be passed: */
    socket: socket,     /* server or socket  */
    online: true,       /* default */
    minify: true,       /* default */
    prefix:'/console'   /* default */
})
```

И на клиенте:

```html
<div class="console"></div>
<script src="/console/console.js"></script>
<script>
Console('.console', function() {
    console.log('console ready')
});
</script>
```

В результате мы получаем консоль, которая может принимать команды на клиенте и выполнять их на сервере.

### Spawnify

Пока мы говорим о выполнении команд, хочется отметить [spawnify](https://github.com/coderaiser/spawnify "Spawnify").
Надстройке над `exec` и `spawn`, которая, кроме всего прочего, генерирует событие `cd`, с помощью которого
можно узнать, что папка сменилась, и вовремя отреагировать на это.

### Edward

![Edward](https://raw.githubusercontent.com/cloudcmd/edward/master/img/edward.png "Edward")

Редактор [Edward](https://github.com/cloudcmd/edward "Edward"), основанный на [ace](http://ace.c9.io "Ace")
так же выделился в отдельный модуль, который может использовать не только Cloud Commander,
но и любое другое приложение, так как это тоже `express middleware`. Из коробки есть горячие клавиши,
а так же `minify` и `beautify`. Для начала использования достаточно кода на сервере:

```js
app.use(edward({
    minify  : true,  /* default */
    online  : false, /* default */
    diff    : true,  /* default */
    zip     : true   /* default */
}));
```

И клиенте :

```html
<div class="edit" data-name="js-edit"></div>
<script src="/edward/edward.js"></script>
```

```css
html, body, .edit {
    height: 100%;
    margin: 0;
}
```

```js
edward('[data-name="js-edit"]', function(el) {
    console.log('edward is ready');
});
```

### Dword

![Dword](https://raw.githubusercontent.com/coderaiser/dword/master/img/dword.png "Dword")

Редактор [Dword](https://github.com/coderaiser/dword "Dword") в плане кода, полностью совместим с Edward.
Основное отличие в том, что Dword основан на [CodeMirror](http://codemirror.net "CodeMirror").
Теперь пользователи Cloud Commander имеют возможность выбирать редактор по вкусу.
И Ace и Codemirror достаточно зрелые проекты. Правда у них обоих есть недостатки:

- с помощью Ace не получится нормально редактировать код на мобильном, поскольку нет возможности скролить код.
- CodeMirror не использует WebWorkers, поэтому, при использовании JSHINT редактор начинает работать медленее, чем Ace.

Во время адаптации CodeMirror к возможности стать полноценной заменой Ace было написано несколько плагинов:

- [CodeMirror Searchbox](https://github.com/coderaiser/cm-searchbox) - аналогичен используемому в Ace, инструмент для
поиска и замены текста.

- [CodeMirror Show Invisibles](https://github.com/coderaiser/cm-show-invisibles) - добавляет режим показа невидимых символов
похожий на тот, что используется в Ace и Chrome Developer Tools, но в отличие от последнего, способен показывать окончания
строк.

Кстати, эта статья частично пишется в редакторе Dword, который вполне пригоден для работы с текстом любого вида.

### Mollify

Последним middleware на сегодня будет [mollify](https://github.com/coderaiser/mollify "mollify"). Он позволяет на лету
минифицировать `js`, `css` и `html`. Для этого он использует *Minify* описанный выше.

### Rendy

Когда нужен действительно простой шаблонизатор [rendy](https://github.com/coderaiser/rendy "Rendy") может пригодится.
Он делает одну вещь. Делает это максимально просто. Работает во всех окружениях, поддерживающих ES5.
Использовать можно таким образом:

```js
    var Tmpl    = 'hello {{ where }}';
        result  = rendy(Tmpl, {
            where: 'in browser'
        });
        // returns
        'hello in browser'
```

### Ponse

В комментариях к предыдущей статье меня спрашивали по-поводу используемого веб-сервера. Так вот, это
[ponse](https://github.com/coderaiser/ponse "Ponse"). Простой веб-сервер. С `express` тягаться не будет,
но с некоторыми вещами справляется неплохо.

### Pipe-io

Когда дело заходит о потоках данных, есть несколько нюансов, которые должны быть учтены.
Например то, что обработчики ошибок должны навешиватся на каждый стрим при использовании
`pipe`. [Pipe-io](https://github.com/coderaiser/pipe-io "Pipe-io") помогает решить
эту проблему, упростив синтаксис до минимума:

```js
 pipe([readStream, writeStream], function(error) {
    console.log(error || 'done');
});
```

Потоков в массиве может быть сколько угодно, на каждый из них навесится обработчик ошибок,
в котором можно будет посмотреть есть ли ошибка и какая.

### Win32

Получить список дисков в Windows можно с помощью специального модуля [win32](https://github.com/coderaiser/win32 "Win32").
Поддерживаются системы от `XP` до `8-ки`.

### Flop

Удалять, копировать, читать и перемещать папки можно с помощью модуля [flop](https://github.com/coderaiser/flop "flop").
Это его основное предназначение.

## Разработка

Процесс разработки не особо изменился, главное отличие в том, что разработка ведется не в одном глобальном репозитории,
а в репозитории модуля, в котором найден баг или нужна новая фича.

Хочется сказать пару слов о последнем на сегодня модуле [publish-io](https://github.com/coderaiser/publish-io "Publish").
Он состоит из нескольких маленьких модулей, каждый из которых упрощает и автоматизирует рутинную работу JavaScript программиста,
такую как:

- генерация `ChengeLog`
- обновление версии в `package.json` и `bower.json` (если существует)
- добавление тега
- публикация в npm
- создание релиза на GitHub

Все эти задачи легко можно было реализовать с помощью `Gulp`. Но копируя очередной раз `gulpfile.js` в новый проект,
я себя словил на мысли, что слишком часто это делаю, и это не очень удобно, все время его за собой тащить.
`Publish-io` не требует конфигурационного файла. Он просто делает все необходимые вещи, которые нужны
перед публикацией модуля. Это не замена для Gulp или Grant. Это просто взгляд с другой стороны.

Мой workflow этот инструмент автоматизировал, упростил и сделал значительно удобнее.

## Послесловие

Несмотря на то, что приложение разбитое на модули гораздо проще поддерживать, время-от-времени случается такое, что
в рамках одного приложения используются разные версии одного и того же модуля. И ошибка, исправленная в одной версии,
продолжает себя проявлять в другой. Такое бывает редко и случается в основном в dev-версии проекта, в которой некоторые
node модули - это symlinks к соответственным репозиториям. В остальном же, с более мелкими частичками гораздо проще работать,
 переиспользовать и разрабатывать их.
 
Мне часто приходится объяснять разработчикам преимущества модульной разработки и иногда это дается очень сложным путем.
Судя по-всему некоторые вещи становятся понятными только тогда, когда человек к этому придет сам.

В любом случае, как бы читатель к этому не пришел, очень надеюсь, что тенденция к маленьким приложениям будет брать верх
перед фреймворками, которые делают сразу много дел. И последние наблюдения в этом направлении вполне оправдывают мои ожидания,
что не может не радовать.
