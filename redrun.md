# Ускоряем npm скрипты с помощью Redrun

## Введение

Таск раннеры существенно упростили жизнь веб разработчиками, автоматизируя рутинные действия связанные с запуском тестов, проверкой кода, объединением в один файл, [транспайлинга](http://ast.rocks/blog/start-using-es6-and-sass-in-browsers-now "Начните использовать ES6 и SASS в браузерах сегодня") и прочих не менее полезных дел. Опустим вопрос необходимости подобных инструментов, конечно, можно и без них, но они существенно упрощают жизнь и делают более качественным процесс разработки.

Все используют таск раннеры в той или иной мере: кто-то старинным [грантом](http://gruntjs.com/), кто-то постепенно уходящим с арены [галпом](http://gulpjs.com/) и [многими другими](http://blog.cozycloud.cc/technic/2014/06/18/task-runners-comparison/), а кто-то уже [во всю](https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8#.v9dp09hrm "Почему я оставил grunt и gulp во-имя npm-скриптов") [использует](http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/ "Почему нам стоит перестать использовать Grunt и Gulp") npm скрипты](https://medium.com/@dabit3/introduction-to-using-npm-as-a-build-tool-b41076f488b0#.e2z3u7pyf "Представление npm, как средства сборки").

Последние мы сегодня разберем во всех деталях, а так же способы их ускорения и расширения возможностей.

## Причины использовать npm как таск раннер

По мере появления перечисленных выше таск раннеров, они были мной испробованы в бою, и в каждом из них (конечно же) есть плюсы, и минусы. Рассмотрим их в кратце.

(Написанное ниже является субъективным опытом, и на истину последней инстанции не претендует, тем-не-менее является важными причинами дальнейшего повествования).

У гранта низкий порог вхождения, благодаря конфигам, который в тот же момент являются его краеугольным камнем, заставляя генерировать их программно, из-за большого количества передаваемых полей. Галп решает эту проблему целиком, добавляя минимализм и скорость выполнения, благодаря стримам (https://github.com/substack/stream-handbook), что повышает порог вхождения, требуя от пользователей понимания того, как все работает изнутри.

Разобравшись со стримами, и написав лаконичный Gulpfile я успокоился и продолжил разработку проекта. Для следующего приложения, я, конечно, снова написал Gulpfile. И для следующих. И для [многих остальных](https://www.npmjs.com/~coderaiser).

После чего сам gulp, и его плагины начали обновляться, а потом и его зависимости, которые бывало нужно [было обновлять самостоятельно](https://github.com/spalger/gulp-jshint#install). Конечно можно не использовать сервисы, следящие за [обновлениями пакетов](https://gemnasium.com/), устранением уязвимостей, исправлением ошибок и всем прочим, но это не самый хороший подход к разработке.

Таким образом мы подошли к главному недостатку большинства такс раннеров: их нужно обновлять, их зависимости нужно обновлять и зависимость зависимостей тоже. Для монолитных приложений это не представляет проблемы. Проблемы начинаются тогда, когда частей приложения много, и каждая из них является независимым модулем, а это ли не [основная парадигма разработки на node.js?](https://docs.npmjs.com/getting-started/what-is-npm)

Итак, вместо того, что бы обновлять: gulp, gulp-jshint и jshint, я лучше просто буду использовать jshint напрямую, с помощью интерфейса командной строки, который не часто меняется, значительно упрощая себе жизнь.

### Минусы

Конечно у такого подхода есть и минусы, куда же без них? Если беспорядочно пихать все подряд в секцию `scripts` файла `package.json`, очень скоро там черт ногу сломит, но не разберется с тем что и как.

### Аналоги
## Взаимодействие
## Вывод

