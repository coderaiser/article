# Ускоряем npm скрипты с помощью Redrun

## Введение

Таск раннеры существенно упростили жизнь веб разработчиками, автоматизируя рутинные действия связанные с запуском тестов, проверкой кода, объединением в один файл, [транспайлинга](http://ast.rocks/blog/start-using-es6-and-sass-in-browsers-now "Начните использовать ES6 и SASS в браузерах сегодня") и прочих не менее полезных дел. Опустим вопрос необходимости подобных инструментов, конечно, можно и без них, но они существенно упрощают жизнь и делают более качественным процесс разработки.

Все используют таск раннеры в той или иной мере: кто-то старинным [грантом](http://gruntjs.com/), кто-то постепенно уходящим с арены [галпом](http://gulpjs.com/) и [многими другими](http://blog.cozycloud.cc/technic/2014/06/18/task-runners-comparison/), а кто-то уже [во всю](https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8#.v9dp09hrm "Почему я оставил grunt и gulp во-имя npm-скриптов") [использует](http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/ "Почему нам стоит перестать использовать Grunt и Gulp") npm скрипты](https://medium.com/@dabit3/introduction-to-using-npm-as-a-build-tool-b41076f488b0#.e2z3u7pyf "Представление npm, как средства сборки").

Последние мы сегодня разберем во всех деталях, а так же способы их ускорения и расширения возможностей.

## Причины использовать npm как таск раннер

По мере появления перечисленных выше таск раннеров, они были мной испробованы в бою, и в каждом из них (конечно же) есть плюсы, и минусы. Рассмотрим их в кратце.

(Написанное ниже является субъективным опытом, и на истину последней инстанции не претендует, тем-не-менее является важными причинами дальнейшего повествования).

У гранта низкий порог вхождения, благодаря конфигам, который в тот же момент являются его краеугольным камнем, заставляя генерировать их программно, из-за большого количества передаваемых полей. Галп решает эту проблему целиком, добавляя минимализм и скорость выполнения, благодаря стримам (https://github.com/substack/stream-handbook), что повышает порог вхождения, требуя от пользователей понимания того, как все работает изнутри.

И так, отойдя от гранта, разобравшись со стримами и написав лаконичный Gulpfile я успокоился и продолжил разработку проекта. Для следующего приложения, я, конечно, снова написал Gulpfile. И для следующих. И для [многих остальных](https://www.npmjs.com/~coderaiser).

После чего сам gulp, и его плагины начали обновляться, а потом и его зависимости, которые бывало нужно [было обновлять самостоятельно](https://github.com/spalger/gulp-jshint#install). Конечно можно не использовать сервисы, следящие за [обновлениями пакетов](https://gemnasium.com/), устранением уязвимостей, исправлением ошибок и всем прочим, но это не самый хороший подход к разработке.

Таким образом мы подошли к главному недостатку большинства такс раннеров: их нужно обновлять, их зависимости нужно обновлять и зависимость зависимостей тоже. Для монолитных приложений это не представляет проблемы. Проблемы начинаются тогда, когда частей приложения много, и каждая из них является независимым модулем, а это ли не [основная парадигма разработки на node.js?](https://docs.npmjs.com/getting-started/what-is-npm)

Итак, вместо того, что бы обновлять: gulp, gulp-jshint и jshint, я лучше просто буду использовать jshint напрямую, с помощью интерфейса командной строки, который не часто меняется, значительно упрощая себе этим жизнь.

### Минусы

Конечно у такого подхода есть и минусы, куда же без них? Если беспорядочно пихать все подряд в секцию `scripts` файла `package.json`, очень скоро там черт ногу сломит. По этому следует использовать короткие команды, и четко отражать их поведение в названии.

### Аналоги

Есть [много библиотек](https://github.com/mysticatea/npm-run-all/issues/10), упрощающих взаимодействие с npm скриптами. Мы рассмотрим одну главную, которая объединяет функционал всех существующих решений, и в то же время, не отходит от существующей парадигмы, а именно: запуск скриптов средствами `npm`.

#### npm-run-all

Когда я начал активно использовать npm скрипты, я, как и многие разработчики, осознал неудобство и многословность такого такого подхода, к примеру, если нужно запустить проверку 3-мя линтерами, код будет выглядеть таким образом:

```js
{
    "lint:jshint": "jshint lib test",
    "lint:eslint": "eslint lib test",
    "lint:jscs": "jscs lib test"
}
```

Тогда скрипта, который все собирает воедино будет выглядит так:

```js
{
  "lint": "npm run lint:jshint && npm run lint:eslint && npm run lint:jscs"
}
```

Получилось очень многословно (гораздо короче чем `grant` и `gulp`, но тем-не-менее) и сложночитаемо.
[npm-run-all](https://github.com/mysticatea/npm-run-all) существенно все упрощает. С его помощью код, делающий тоже самое, будет выглядеть так:

```js
{
  "lint": "npm-run-all lint:jshint lint:eslint lint:jscs"
}
```

(`npm-run-all` можно смело заменять на более короткое название: `run-s`, крайние версии `npm-run-all` это поддерживают)

И делать примерно то же самое: поочередно запускать скрипты.

`npm-run-all` очень не плохо себя показывает в плане удобства, но по принципу действия он не сильно уходить от `npm run`: каждая команда вызывается отдельно, что значительно замедляет весь процесс.

## Redrun

Принцип действия `redrun` значительно отличается от перечисленных выше аналогов: вместо того, что бы запускать каждую команду отдельно, он объединяет все вложенные команды в одну большую и уже ее передает на выполнение системному шеллу. Благодаря такой оптимизации, скорость выполнения `npm-скриптов` существенно возрастает, при этом остается возможность запуска скриптов параллельно и последовательно.

## Взаимодействие

Рассмотрим пример использования `redrun`. Для начала установка (ничего особенного):

```sh
$ npm i redrun -g
```

Дальше инициализируем `package.json` с помощью `npm init -y`:

```sh
$ mkdir example
$ cd example
$ npm init -y

Wrote to /home/coderaiser/example/package.json:

{
  "name": "example",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "coderaiser"
  "license": "MIT",
  "description": ""
}
```

Установим `tape` для тестов, и запишем простейший тест, который проходит.

```sh
npm i tape -D
echo -e "const test = require('tape');\ntest('some test', (t) => t.end());" > test.js
```

Теперь в секцию `scripts` добавим пару разделов:

```js
{
    "test": "tape 'test/**/*.js'",
    "watch:test": "npm run watcher -- npm test",
    "watcher": "nodemon -w test -w lib --exec",
}
```

После чего запустим тест с помощью `npm`:

```sh
$ time npm test

reel   0m6.617s
user   0m1.262s
sys    0m1.778s
```

А теперь то же самое, только с помощью `redrun`:

```sh
$ time redrun test

real    0m2.389s
user    0m0.495s
sys     0m0.544s
```

Даже на таком простом примере видно, что скорость выполнения почти в 3 раза выше.

Теперь попробуем тоже самое со скриптом `npm watch:test`:

```sh
$ time redrun watch:test
> nodemon -w test -w lib --exec tape 'test/**/*.js'
/bin/sh: 1: nodemon: not found
Command failed: nodemon -w test -w lib --exec tape 'test/**/*.js'

real    0m1.211s
user    0m0.208s
sys    0m0.332s
```

Ага, `nodemon` мы не установили, и нам потребовалась всего 1 секунда, что бы это узнать. Хочу обратить внимания читателя, на то, что команда полностью развернулась, и `nodemon` будет перезапускать не посредственно `tape`, а не `npm test`.

Попробуем тоже-самое выполнить с помощью `npm`:

```sh
> article@1.0.0 watch:test /home/coderaiser/article
> npm run watcher -- npm test


> article@1.0.0 watcher /home/coderaiser/article
> nodemon -w test -w lib --exec "npm" "test"

sh: 1: nodemon: not found

npm ERR! syscall spawn
npm ERR! spawn ENOENT
npm ERR! article@1.0.0 watch:test: `npm run watcher -- npm test`
npm ERR! Exit status 1

real    0m11.594s
user    0m2.181s
sys     0m2.849s
```

С помощью `npm` нам потребовалось 11 секунд, для того, что бы узнать, что `nodemon` не установлен.

## Вывод

`npm` хороший инструмент, который исправно выполняет то, для чего предназначен. Экосистема `node.js` гораздо стремительнее эволюционирует чем в аналогичных языках, и не последнее место в этом процессе отыгрывает `npm` (а одно из первых). Я думаю, придет момент, когда `redrun` станет не нужен в силу того, что `npm` и так все быстро будет делать. Но пока этот момент не наступил, и для того, что бы его приблизить, создан помощник `npm` в таком непростом деле как запуск скриптов.

